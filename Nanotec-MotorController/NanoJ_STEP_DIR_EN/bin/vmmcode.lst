ARM GAS  C:\Windows\ccipzwDD.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"mapping.cxx"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	In
  19              		.section	.inputs,"aw",%progbits
  20              		.align	2
  23              	In:
  24 0000 00000000 		.space	4
  25              		.global	Out
  26              		.section	.outputs,"aw",%progbits
  27              		.align	2
  30              	Out:
  31 0000 0000     		.space	2
  32 0002 0000     		.text
  33              	.Letext0:
  34              		.file 1 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen\\types
  35              		.file 2 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen\\mappi
  36              		.file 3 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen\\mappi
ARM GAS  C:\Windows\ccipzwDD.s 			page 2


DEFINED SYMBOLS
                            *ABS*:00000000 mapping.cxx
C:\Windows\ccipzwDD.s:23     .inputs:00000000 In
C:\Windows\ccipzwDD.s:20     .inputs:00000000 $d
C:\Windows\ccipzwDD.s:30     .outputs:00000000 Out
C:\Windows\ccipzwDD.s:27     .outputs:00000000 $d

NO UNDEFINED SYMBOLS
ARM GAS  C:\Windows\ccipzwDD.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"vmmcode.cpp"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text._Z4userv,"ax",%progbits
  19              		.align	2
  20              		.global	_Z4userv
  21              		.thumb
  22              		.thumb_func
  24              	_Z4userv:
  25              	.LFB0:
  26              		.file 1 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen\\mappi
   1:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** /*
   2:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** This NanoJ Example Code is based on our experience with typical user requirements in a wide range
   3:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** of industrial applications and is provided without guarantee regarding correctness and completeness
   4:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** It serves as general guidance and should not be construed as a commitment of Nanotec to guarantee i
   5:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** applicability to the customer application without additional tests under the specific conditions
   6:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** and – if and when necessary – modifications by the customer. 
   7:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
   8:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** The responsibility for the applicability and use of the NanoJ Example Code in a particular
   9:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** customer application lies solely within the authority of the customer.
  10:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** It is the customer's responsibility to evaluate, investigate and decide,
  11:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** whether the Example Code is valid and suitable for the respective customer application, or not.
  12:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** Defects resulting from the improper handling of devices and modules are excluded from the warranty.
  13:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** Under no circumstances will Nanotec be liable for any direct, indirect, incidental or consequential
  14:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** arising in connection with the Example Code provided. In addition, the regulations regarding the
  15:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** liability from our Terms and Conditions of Sale and Delivery shall apply.
  16:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** */
  17:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  18:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** // in this example the operationmode will be set to clock direction mode and enabled with an input
  19:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  20:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** //1. Step: mapping the frequently used SDO´s
  21:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** // map U16 ControlWord as output 0x6040:00
  22:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** // map U32 Inputs as input 0x60FD:00
  23:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  24:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** #include "wrapper.h"
  25:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  26:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** //2. Step: call Main function and make nevessary settings
  27:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  28:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** void user()
  29:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** {
  27              		.loc 1 29 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
ARM GAS  C:\Windows\ccipzwDD.s 			page 2


  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 7, -8
  34              		.cfi_offset 14, -4
  35 0002 82B0     		sub	sp, sp, #8
  36              		.cfi_def_cfa_offset 16
  37 0004 00AF     		add	r7, sp, #0
  38              		.cfi_def_cfa_register 7
  39              	.LBB2:
  30:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	bool bEnabled = false;  			// bool variable with name "bEnabled"
  40              		.loc 1 30 0
  41 0006 0023     		movs	r3, #0
  42 0008 FB71     		strb	r3, [r7, #7]
  31:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
  32:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	od_write(0x6060, 0x00, 0xff);		// set the mode of operation to clock-direction mode (0xff = -1)
  43              		.loc 1 32 0
  44 000a 46F26000 		movw	r0, #24672
  45 000e 0021     		movs	r1, #0
  46 0010 FF22     		movs	r2, #255
  47 0012 FFF7FEFF 		bl	od_write
  33:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
  34:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** //3. Step: switch on the state machine, use enable input
  35:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  36:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	Out.ControlWord = 0x6;				// switch to the "enable voltage" state
  48              		.loc 1 36 0
  49 0016 40F20003 		movw	r3, #:lower16:Out
  50 001a C0F20003 		movt	r3, #:upper16:Out
  51 001e 0022     		movs	r2, #0
  52 0020 42F00602 		orr	r2, r2, #6
  53 0024 1A70     		strb	r2, [r3]
  54 0026 0022     		movs	r2, #0
  55 0028 5A70     		strb	r2, [r3, #1]
  56              	.L2:
  37:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	do 	{
  38:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		yield();						// waiting for the next cycle (1ms)
  57              		.loc 1 38 0 discriminator 1
  58 002a FFF7FEFF 		bl	yield
  39:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		}
  40:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		while ( (od_read(0x6041, 0x00) & 0xEF) != 0x21);   // wait until drive is in state "enable voltag
  59              		.loc 1 40 0 discriminator 1
  60 002e 46F24100 		movw	r0, #24641
  61 0032 0021     		movs	r1, #0
  62 0034 FFF7FEFF 		bl	od_read
  63 0038 0346     		mov	r3, r0
  64 003a 03F0EF03 		and	r3, r3, #239
  37:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	do 	{
  65              		.loc 1 37 0 discriminator 1
  66 003e 212B     		cmp	r3, #33
  67 0040 0CBF     		ite	eq
  68 0042 0023     		moveq	r3, #0
  69 0044 0123     		movne	r3, #1
  70 0046 DBB2     		uxtb	r3, r3
  71 0048 002B     		cmp	r3, #0
  72 004a EED1     		bne	.L2
  73              	.L8:
  41:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
ARM GAS  C:\Windows\ccipzwDD.s 			page 3


  42:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  43:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	// checking the statusword (0x6041) for the bitmask: xxxx xxxx x01x 0001
  44:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
  45:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
  46:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	while(true)
  47:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	{
  48:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		// Input Pins 1#10000 2#20000 3#40000 4#80000 5#100000
  49:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		if((In.Inputs & 0x100000) != 0)  // ### checking input 5 for not low // EN PIN 
  74              		.loc 1 49 0
  75 004c 40F20003 		movw	r3, #:lower16:In
  76 0050 C0F20003 		movt	r3, #:upper16:In
  77 0054 1B68     		ldr	r3, [r3]	@ unaligned
  78 0056 03F48013 		and	r3, r3, #1048576
  79 005a 002B     		cmp	r3, #0
  80 005c 3ED0     		beq	.L3
  50:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		{	
  51:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			if (bEnabled == false)		// motor is not running
  81              		.loc 1 51 0
  82 005e FB79     		ldrb	r3, [r7, #7]
  83 0060 83F00103 		eor	r3, r3, #1
  84 0064 DBB2     		uxtb	r3, r3
  85 0066 002B     		cmp	r3, #0
  86 0068 58D0     		beq	.L4
  52:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			{
  53:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				bEnabled = true;		// then start the motor with...
  87              		.loc 1 53 0
  88 006a 0123     		movs	r3, #1
  89 006c FB71     		strb	r3, [r7, #7]
  54:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				Out.ControlWord = 0x7;	// switch to the "switched on" state
  90              		.loc 1 54 0
  91 006e 40F20003 		movw	r3, #:lower16:Out
  92 0072 C0F20003 		movt	r3, #:upper16:Out
  93 0076 0022     		movs	r2, #0
  94 0078 42F00702 		orr	r2, r2, #7
  95 007c 1A70     		strb	r2, [r3]
  96 007e 0022     		movs	r2, #0
  97 0080 5A70     		strb	r2, [r3, #1]
  98              	.L5:
  55:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
  56:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 						yield();						// waiting for the next cycle (1ms)
  99              		.loc 1 56 0 discriminator 1
 100 0082 FFF7FEFF 		bl	yield
  57:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					}
  58:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					while ( (od_read(0x6041, 0x00) & 0xEF) != 0x23);   // wait until drive is in state "switched o
 101              		.loc 1 58 0 discriminator 1
 102 0086 46F24100 		movw	r0, #24641
 103 008a 0021     		movs	r1, #0
 104 008c FFF7FEFF 		bl	od_read
 105 0090 0346     		mov	r3, r0
 106 0092 03F0EF03 		and	r3, r3, #239
  55:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
 107              		.loc 1 55 0 discriminator 1
 108 0096 232B     		cmp	r3, #35
 109 0098 0CBF     		ite	eq
 110 009a 0023     		moveq	r3, #0
 111 009c 0123     		movne	r3, #1
 112 009e DBB2     		uxtb	r3, r3
ARM GAS  C:\Windows\ccipzwDD.s 			page 4


 113 00a0 002B     		cmp	r3, #0
 114 00a2 EED1     		bne	.L5
  59:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					// checking the statusword (0x6041) for the bitmask: xxxx xxxx x01x 0011				
  60:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				Out.ControlWord = 0xF;	// switch to the "enable operation" state and starts the velocity mode
 115              		.loc 1 60 0
 116 00a4 40F20003 		movw	r3, #:lower16:Out
 117 00a8 C0F20003 		movt	r3, #:upper16:Out
 118 00ac 0022     		movs	r2, #0
 119 00ae 42F00F02 		orr	r2, r2, #15
 120 00b2 1A70     		strb	r2, [r3]
 121 00b4 0022     		movs	r2, #0
 122 00b6 5A70     		strb	r2, [r3, #1]
 123              	.L6:
  61:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
  62:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 						yield();						// waiting for the next cycle (1ms)
 124              		.loc 1 62 0 discriminator 1
 125 00b8 FFF7FEFF 		bl	yield
  63:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					}
  64:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					while ( (od_read(0x6041, 0x00) & 0xEF) != 0x27);   // wait until drive is in state "operation 
 126              		.loc 1 64 0 discriminator 1
 127 00bc 46F24100 		movw	r0, #24641
 128 00c0 0021     		movs	r1, #0
 129 00c2 FFF7FEFF 		bl	od_read
 130 00c6 0346     		mov	r3, r0
 131 00c8 03F0EF03 		and	r3, r3, #239
  61:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
 132              		.loc 1 61 0 discriminator 1
 133 00cc 272B     		cmp	r3, #39
 134 00ce 0CBF     		ite	eq
 135 00d0 0023     		moveq	r3, #0
 136 00d2 0123     		movne	r3, #1
 137 00d4 DBB2     		uxtb	r3, r3
 138 00d6 002B     		cmp	r3, #0
 139 00d8 EED1     		bne	.L6
 140 00da 1FE0     		b	.L4
 141              	.L3:
  65:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					// checking the statusword (0x6041) for the bitmask: xxxx xxxx x01x 0111	
  66:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			}
  67:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		}
  68:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		else                			// if input 1 is low
  69:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		{	
  70:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			if (bEnabled == true)		// motor is started
 142              		.loc 1 70 0
 143 00dc FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 144 00de 002B     		cmp	r3, #0
 145 00e0 1CD0     		beq	.L4
  71:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			{
  72:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				bEnabled = false;		// then stop the motor with...
 146              		.loc 1 72 0
 147 00e2 0023     		movs	r3, #0
 148 00e4 FB71     		strb	r3, [r7, #7]
  73:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				Out.ControlWord = 0x6;	// switch to the "enable voltage" state 
 149              		.loc 1 73 0
 150 00e6 40F20003 		movw	r3, #:lower16:Out
 151 00ea C0F20003 		movt	r3, #:upper16:Out
 152 00ee 0022     		movs	r2, #0
 153 00f0 42F00602 		orr	r2, r2, #6
ARM GAS  C:\Windows\ccipzwDD.s 			page 5


 154 00f4 1A70     		strb	r2, [r3]
 155 00f6 0022     		movs	r2, #0
 156 00f8 5A70     		strb	r2, [r3, #1]
 157              	.L7:
  74:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
  75:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 						yield();						// waiting for the next cycle (1ms)
 158              		.loc 1 75 0 discriminator 1
 159 00fa FFF7FEFF 		bl	yield
  76:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					}
  77:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					while ( (od_read(0x6041, 0x00) & 0xEF) != 0x21);   // wait until drive is in state "enable vol
 160              		.loc 1 77 0 discriminator 1
 161 00fe 46F24100 		movw	r0, #24641
 162 0102 0021     		movs	r1, #0
 163 0104 FFF7FEFF 		bl	od_read
 164 0108 0346     		mov	r3, r0
 165 010a 03F0EF03 		and	r3, r3, #239
  74:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 				do 	{
 166              		.loc 1 74 0 discriminator 1
 167 010e 212B     		cmp	r3, #33
 168 0110 0CBF     		ite	eq
 169 0112 0023     		moveq	r3, #0
 170 0114 0123     		movne	r3, #1
 171 0116 DBB2     		uxtb	r3, r3
 172 0118 002B     		cmp	r3, #0
 173 011a EED1     		bne	.L7
 174              	.L4:
  78:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	
  79:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 					// checking the statusword (0x6041) for the bitmask: xxxx xxxx x01x 0001
  80:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 			}
  81:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		}
  82:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 
  83:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 		yield();						// waiting for the next cycle (1ms)
 175              		.loc 1 83 0
 176 011c FFF7FEFF 		bl	yield
  84:C:\Plug & Drive Studio\PNDS-2.0.5-x86\workspace\Stepper_NanoJ_STEP_DIR_EN\gen\mappings\vmmcode.cpp **** 	} 
 177              		.loc 1 84 0
 178 0120 94E7     		b	.L8
 179              	.LBE2:
 180              		.cfi_endproc
 181              	.LFE0:
 183 0122 00BF     		.text
 184              	.Letext0:
 185              		.file 2 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen/types.
 186              		.file 3 "C:\\Plug & Drive Studio\\PNDS-2.0.5-x86\\workspace\\Stepper_NanoJ_STEP_DIR_EN\\gen/mappin
ARM GAS  C:\Windows\ccipzwDD.s 			page 6


DEFINED SYMBOLS
                            *ABS*:00000000 vmmcode.cpp
C:\Windows\ccipzwDD.s:19     .text._Z4userv:00000000 $t
C:\Windows\ccipzwDD.s:24     .text._Z4userv:00000000 _Z4userv
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
od_write
Out
yield
od_read
In
